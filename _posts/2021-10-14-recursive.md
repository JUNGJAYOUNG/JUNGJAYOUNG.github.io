---
title: "Java Basic: this-this()-static-overloading"
categories:
  - Java Basic
tags:
  - this
  - this()
  - static
  - method overloading

---
## 재귀호출

**메소드안에서 자기자신을 계속 반복하여 호출**하는 경우를 말한다.
재귀호출 메소드를 만들때에는 반드시 ~~끝나는 조건~~을 만들어야 한다.

예제) n을 매개변수로 전달받아 n!을 구하여 반환하는 메소드를 재귀호출로 정의
```java
public static int getFactorial(int n){
    if(n==1){	//끝나는 조건 반드시 필요
		return 1;
	}return n*getFactorial(n-1);
}
System.out.println( getFactorial(3) ) ;
```
## 클래스와 상속

* 부모클래스(상위클래스):상속 해준 클래스
* 자식클래스(하위클래스):상속 받은 클래스
```
class A{

}

class B extends A{

}
```
A는 부모클래스, B는 자식클래스

자식클래스는 부모클래스의 모든 속성 및 동작에 접근할 수 있다.

단, 자식 클래스라도**부모클래스의 private영역에는 접근할 수 없다.**
-> 자식클래스가 접근할 수 있게 하려면 **protected영역에 둘 것** 
`protected int name; //자식 클래스만 접근 가능``

상속의 장점: 코드의 재사용성을 높일 수 있다.

## 상속과 생성자

생성자는 객체 생성시에 초기화를 위해 자동으로 수행되는 메소드이다.

상속관계에서는
**부모 클래스의 생성자가 먼저 동작**하고 자식 클래스의 생성자가 나중에 동작한다.
```
class A{
	public A(){
	
	}
}
class B extend A{
	public B(){	//생성자를 정의하지 않았을 경우엔 기본생성자가 자동 생성됨
		//super(); 생략되어 있음	
	}
}
```
`B ob = new B(); //A의 생성자가 먼저 동작하고 B의 생성자가 동작`

자식클래스의 생성자의 첫번째 줄에는 
`super();` 가 생략되어 있다. -> 부모클래스 생성자 호출

*주의! 생성자를 별도로 정의할 경우, 기본생성자가 자동으로 생성되지 않는다. 
->부모클래스에 기본생성자를 만들어 주거나
->자식클래스의 생성자에서 부모클래스의 매개변수를 갖는 생성자를 요구해야한다.

--------------------
## 메소드 오버로딩 vs 메소드 오버라이딩

* 메소드 오버로딩
: 동일한 메소드 이름으로 **인수만 달리하여 여러 기능을 정의**하는 것
단, 중복하여 정의하기 위해서는 메소드의 **매개변수의 개수나 자료형이 달라야 한다.**


* 메소드 오버라이딩(재정의)
: **상속받은 메소드의 내용을 변경하여 재정의**하는 것
단, 메소드이름, 반환자료형, 매개변수의 개수와 자료형까지 모두 일치되게 재정의해야한다.
-> 오버라이딩 했을 경우 자식 클래스의 메소드가 동작한다.