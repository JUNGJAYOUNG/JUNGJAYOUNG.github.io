---
title: "Java Basic: Array-Method"
categories:
  - Java Basic
tags:
  - array
  - method

---

## 배열(Array)
자료형이 같은 기억장소의 모임

`int a[]; 		//a는 배열의 이름이고 []기호는 배열임을 표시한다.`
`a=new int[5];	//a가 int형 5개만큼 메모리를 확보하라는 의미`

위의 두 문장을 한 줄로 표현할 수도 있다.

`int a[] = new int[5];`	
`int []a = new int[5];`

배열기호[]를 배열이름 앞에 쓸 수도 있고, 뒤에 쓸 수도 있다.

배열의 요소가 처음부터 정해진 경우라면 배열을 선언함과 동시에 초기화 할 수도 있다.
`int []a = {10,20,30,40,50};`

위와 같이 배열을 선언함과 동시에 초기화하게 되면 자동으로 배열의 길이는
초기화한 데이터의 수만큼 정해진다.

**또, 배열은 자동으로 초기값을 가진다.**
자료형에 따라 boolean은 false, String null, 정수는 0, 실수는 0.0 등으로 초기화 된다.

``` 
int a;
System.out.println(a);	//값 초기화하지 않아 오류 발생!`
```
그러나 배열의 경우
```
int []b = new b[5];`
System.out.println(b[0]);	//0이 출력된다.`
```
별도로 초기화하지 않아도, 자동으로 초기화가 되기 때문에,
위와 같은 출력문을 사용할 수 있다.

그러나 배열을 선언하기만 하고 배열의 메모리 확보를 하기 전에는 사용할 수 없다.

```java
int []k;
k[0]=5;	//오류 발생! 아직 배열 크기가 정해지기 전이기 때문에 사용할 수 없다.
```
------
## 다차원 배열
	배열안에 또, 배열이 있을 수 있다.

* 일차원 배열
	`int []a = new int[5]`
* 이차원 배열
	만약에 5개짜리 정수형 변수가 3묶음 필요하다면 다음과 같이 표현할 수 있다.
	`int [][]a = new int[3][5];	//3행 5열의 이차원 배열`
    * 2차원 배열 이상을 "다차원 배열" 이라고 한다.
	* 2차원 배열을 일괄처리 하려면 중첩반복문 사용해야 한다.
* 삼차원 배열
	만약에 5칸짜리 정수형 변수가 3묶음 있고 그런 것이 2장 필요하다면
	다음과 같이 표현할 수 있다.
	
	`int [][][]a = new int[2][3][5];	//2면,3행,5열`
	
	* 이것을 일괄처리하기 위해서는 세개의 중첩반복문이 필요하다.
	* 특별한 경우가 아니면 3차원배열 이상은 잘 사용하지 않는다.	

### 배열의 단점
	* 자료형이 같아야 한다.
	* 크기가 고정되어 있다.

int []a = new int[5] 라고 해두면
int 밖에 담을 수 없고
5개밖에 담을 수 없다.

사용자가 어떤 자료형을 담을지 또, 몇개를 담을지 예측하기
어려운 경우에는 배열을 사용하기에는 불편하다.

이러한 배열의 단점을 보완하기 위해
자바는 **향상된 배열인 컬렉션 프레임워크를 제공한다.**

따라서 기본자료형의 배열보다는 
컬렉션 프레임워크를 사용하는 것이 일반적이다.

------
자바의 2차원배열에서는 각 행마다 열의 크기가 다를 수 있다.
`int [][]a = {{1,2},{3,4,5,6},{7,8,9}};
```java
for(int i=0; i<3;i++){
	for(int j=0;j<a[i].length;j++){	//행마다 열의 크기가 다른 경우
	
	}
}
```
자바에서는 각 행마다
열의 크기가 다를 수 있으므로
배열의 길이를 위한 속성을 사용한다.

2차원 배열명인 a.length는 3
2차원 배열의 첫번째 요소인
a[0].length는 2이다.
두번째 요소인
a[1].length는 4이다.

----

## 기본자료형 변수와 참조자료형 변수

기본자료형 변수는 변수 자신이 값을 가지지만
참조자료형 변수는 변수 자신이 값을 갖고 있는 것이 아니라
값이 있는 메모리를 참조한다.

`int a = 10;

위의 문장에서 a는 기본자료형 변수이며
변수자신이 10이라는 값을 갖고 있다.

그러나 다음의 배열에서는
`int []b = {10,20,30,40,50};

배열이름 b는 변수자신이 값을 갖고 있는 것이 아니라
값이 있는 메모리를 참조한다.
이러한 배열을 참조자료형이라고 한다.

---

## 메소드
	어떠한 문제해결을 위한(기능을 위한) 서로 관련있는 명령어들의 집합

어떤 일을 수행하기 위한 명령어들이 빈번하게 사용이 된다면
그 일을 처리하기 위한 명령어들을 모아서 메소드로 만들어 두면
매번 똑같은 명령어를 일일히 쓰지 않고 메소드를 호출하여 사용할 수 있다.

```
메소드이름(자료형 변수명1, 자료형 변수명2,,,,){
	메소드가 해야할 명령어(들)
}
```
때로는 메소드{} 중간에서 
다 끝나기도 전에 어떠한 상황에 따라
중간에 나머지 명령어들을 마저 동작하지 않고
되돌아가게 할 수도 있다.
그 때 되돌아가게 하기 위한 명령어는 `return;`

메소드 {} 의 맨끝에는
~~return이라는 말을 쓰지 않아도 생략이 된 것이다.~~

리턴값의 자료형을 메소드 이름 왼쪽에 적는다
리턴값이 없는 경우에는 void를 적는다.

```
void 메소드 이름(){}	//리턴값이 없는 메소드
	return();
}
```
```java
int 메소드 이름(){}	//int형 리턴값을 갖는 메소드
	int sum = 0;
	...
	
	return sum;
}
```
메소드를 만들기 위해서는
메소드를 사용하는 클래스 안에서 메소드를 만들 수도 있고
별도의 메소드를 포함하는 클래스를 만들어 사용할 수도 있다.

* 객체 생성 후 사용하는 방법(별도의 클래스에 메소드 정의)

ex) scanner의 next메소드를 사용, date의 getYear를 사용할 때처럼
객체 생성 후에 
`객체.메소드명()` 으로 호출한다.

* 객체 없이도 사용하는 방법(static 메소드로 정의)

메소드이름 왼쪽에 static 붙이면
객체를 생성하지 않고 `클래스명. 메소드명()`으로 바로 사용할 수 있다.

-----

```java
class MyUtil{
	void gugudan(int dan){
		Systm.out.printf("*** %d단 ***\ㅜ")'
		for(int i=1;i<9=.i++){
			System.out.printf("%d*%d=%d",dan,i,dan*i);
		}
	}	//리턴값이 없다
}
```
```java
class MethodTest01(){
	public static void main(String []args){
		MyUtil mu = new MyUtil();
        mu.gugudan();	//사용하려는 메소드의 매개변수의 자료형과 전달하려는 
        			    //값의 자료형과, 매개변수의 개수가 일치해야 한다!
}
```

** 하나의 파일에 두개 이상의 클래스를 만들때에는 
메인메소드를 포함하는 클래스이름으로 파일명을 저장한다.**

보통은 어떤 메소드를 사용하려면 그 메소드가 있는 
클래스의 객체를 생성하고 그 객체를 통해서 메소드가 호출된다.
그런데 그 메소드가 static이라면 객체를 통하지 않고 바로 클래스 이름으로 사용할 수 있다.

```java
int 메소드이름(){
	int sum=0;
	....
	
	return sum;
}
```

---

### 배열을 매개변수로 갖는 메소드

메소드자료형 메소드이름(자료형 []배열이름){
	
}
```java
void pro(int []data){	//int 형 배열을 매개변수로 받는 메소드 정의

}

int a = {1,2,3,4};
pro(a);	//메소드 호출 (배열 이름 전달)

```
이때 호출하는 배열이름과 메소드의 메개변수의 배열이름은 같아도 달라도 상관없다.
